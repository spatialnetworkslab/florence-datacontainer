# Florence DataContainer

A simple, light-weight interface to manage data. Designed for use with [florence](https://github.com/spatialnetworkslab/florence).

## API Reference

* [Loading data](#loading-data)
* [Accessing data](#accessing-data)
* [Domains and types](#domains-and-types)
* [Data validation](#data-validation)
* [Transformations](#transformations)
* [Adding and removing rows](#adding-and-removing-rows)]

### Loading data

`DataContainer` currently supports 3 data structures:

- Column-oriented data
- Row-oriented data
- GeoJSON

More structures might be supported in the future.
`DataContainer` internally stores data in a [column-oriented](https://www.kdnuggets.com/2017/02/apache-arrow-parquet-columnar-data.html) format.
This means that loading column-oriented data will be faster than row-oriented data.

`DataContainer` supports 6 data types. These data types correspond to native JS data types/structures (see table below).

|  Data type   |                                          JS equivalent                                           |        Loadable         | Column name |
| ------------ | ------------------------------------------------------------------------------------------------ | ----------------------- | ----------- |
| quantitative | `Number`                                                                                         | yes                     | NA          |
| categorical  | `String`                                                                                         | yes                     | NA          |
| temporal     | `Date`                                                                                           | yes                     | NA          |
| interval     | `Array` of two `Number`s                                                                         | yes                     | NA          |
| geometry     | [GeoJSON geometry](https://tools.ietf.org/html/rfc7946#appendix-A) (except `GeometryCollection`) | only by loading GeoJSON | `$geometry` |
| grouped      | `DataContainer`                                                                                  | No                      | `$grouped`  |

Data of the types quantitative, categorical, temporal and interval are 'loadable', which means that they can be passed 
in either column-oriented or row-oriented format to the `DataContainer` constructor. 
Geometry data can only be loaded from [GeoJSON](#loading-geojson-data).
Geometry data can only exists in a column called `$geometry`.
Grouped data is not loadable: it can only be generated by using `.groupBy` or `.bin` transformations (see [Transformations](#transformations)).
A column of grouped data is just a column of other `DataContainer`s.
Grouped data can only exist in a column called `$grouped`.

#### Loading column- and row-oriented data

```js
// Column-oriented data
const columnOriented = new DataContainer({
  fruit: ['apple', 'banana', 'coconut', 'durian'],
  amount: [1, 2, 3, 4]
})

// Row-oriented data
const rowOriented = new DataContainer([
  { fruit: 'apple', amount: 1 },
  { fruit: 'banana', amount: 2 },
  { fruit: 'coconut', amount: 3 },
  { fruit: 'durian', amount: 4 }
])

const s = JSON.stringify

s(columnOriented.column('fruit')) === s(rowOriented.column('fruit')) // true
s(columnOriented.column('amount')) === s(rowOriented.column('amount')) // true

```

#### Loading GeoJSON data

When loading [GeoJSON FeatureCollection](https://tools.ietf.org/html/rfc7946#section-1.5)s, the geometry data will end up in a
column called `$geometry`:

```js
const geojson = new DataContainer({
  type: 'FeatureCollection',
  features: [
    {
      type: 'Feature',
      geometry: {
        type: 'Point', coordinates: [0, 0]
      },
      properties: {
        fruit: 'apple', amount: 1
      }
    }
  ]
})

geojson.column('$geometry') // [{ type: 'Point', coordinates: [0, 0] }]
geojson.column('fruit') // ['apple']

```

### Accessing data

<a name="datacontainer_data" href="#datacontainer_data">#</a> <i>DataContainer</i>.<b>data</b>()

Returns whatever data is currently loaded to the `DataContainer` in a column-oriented format.

```js
const dataContainer = new DataContainer([
  { fruit: 'apple', amount: 1 },
  { fruit: 'banana', amount: 2 }
])

dataContainer.data() // { fruit: ['apple', 'banana'], amount: [1, 2], $key: [0, 1] }
```

<a name="datacontainer_row" href="#datacontainer_row">#</a> <i>DataContainer</i>.<b>row</b>(key)

Returns an object representing a row.

```js
const dataContainer = new DataContainer({ fruit: ['apple', 'banana'], amount: [1, 2] })
dataContainer.row(0) // { fruit: 'apple', amount: 1, $key: 0 }
```

<a name="datacontainer_prevrow" href="#datacontainer_prevrow">#</a> <i>DataContainer</i>.<b>prevRow</b>(key)

Returns the previous row.

```js
const dataContainer = new DataContainer({ fruit: ['apple', 'banana'], amount: [1, 2] })
dataContainer.prevRow(1) // { fruit: 'apple', amount: 1, $key: 0 }
```

<a name="datacontainer_nextrow" href="#datacontainer_nextrow">#</a> <i>DataContainer</i>.<b>nextRow</b>(key)

Returns the next row.

```js
const dataContainer = new DataContainer({ fruit: ['apple', 'banana'], amount: [1, 2] })
dataContainer.nextRow(0) // { fruit: 'banana', amount: 2, $key: 1 }
```

<a name="datacontainer_rows" href="#datacontainer_rows">#</a> <i>DataContainer</i>.<b>rows</b>()

Returns an Array of rows.

```js
const dataContainer = new DataContainer({ fruit: ['apple', 'banana'], amount: [1, 2] })
dataContainer.rows() 
/* [
 *   { fruit: 'apple', amount: 1, $key: 0 },
 *   { fruit: 'banana', amount: 2, $key: 1 },
 * ] 
 */
```

<a name="datacontainer_column" href="#datacontainer_column">#</a> <i>DataContainer</i>.<b>column</b>(columnName)

Returns a column as an Array.

```js
const dataContainer = new DataContainer({ fruit: ['apple', 'banana'], amount: [1, 2] })
dataContainer.column('fruit') // ['apple', 'banana']
dataContainer.column('$key') // [0, 1]
```

<a name="datacontainer_map" href="#datacontainer_map">#</a> <i>DataContainer</i>.<b>map</b>(columnName, func)

Equivalent to `.column(columnName).map(func)`

### Domains and types

<a name="datacontainer_domain" href="#datacontainer_domain">#</a> <i>DataContainer</i>.<b>domain</b>(columnName)

Returns the domain of a column.

```js
const dataContainer = new DataContainer({
  fruit: ['apple', 'banana', 'apple', 'banana'],
  quantity: [1, 2, 3, 4],
  dayOfSale: [new Date(2019, 4, 3), new Date(2019, 4, 4), new Date(2019, 4, 5), new Date(2019, 4, 6)]
})

dataContainer.domain('fruit') // ['apple', 'banana']
dataContainer.domain('quantity') // [1, 4]
dataContainer.domain('dayOfSale') // [Date Fri May 03 2019 ..., Date Mon May 06 2019 ...]
```

For geometry data, this will return the bounding box.

<a name="datacontainer_type" href="#datacontainer_type">#</a> <i>DataContainer</i>.<b>type</b>(columnName)

Returns the type of a column.

```js
const dataContainer = new DataContainer({
  fruit: ['apple', 'banana', 'apple', 'banana'],
  quantity: [1, 2, 3, 4],
  dayOfSale: [new Date(2019, 4, 3), new Date(2019, 4, 4), new Date(2019, 4, 5), new Date(2019, 4, 6)]
})

dataContainer.type('fruit') // categorical
dataContainer.type('quantity') // quantitative
dataContainer.type('dayOfScale') // temporal
```

### Data validation

TODO

### Transformations

`DataContainer`'s transformations are heavily inspired by R's [dplyr](https://dplyr.tidyverse.org/) 
(part of the [tidyverse](https://www.tidyverse.org/)). All transformations will return a new `DataContainer`. For transformations
where it makes sense like `filter`, [immer](https://github.com/immerjs/immer) is used to avoid unnecessary deep cloning while still allowing subsequent transformations without modifying the original data.

<a name="datacontainer_select" href="#datacontainer_select">#</a> <i>DataContainer</i>.<b>select</b>(selectInstructions)

`select` returns a `DataContainer` with only the columns specified in `selectInstructions`. `selectInstructions` can be a single `String` column name, or an `Array` of column names.

```js
const dataContainer = new DataContainer({
  fruit: ['apple', 'banana', 'apple', 'banana'],
  quantity: [1, 2, 3, 4],
  dayOfSale: [new Date(2019, 4, 3), new Date(2019, 4, 4), new Date(2019, 4, 5), new Date(2019, 4, 6)]
})

const withoutDayOfSale = dataContainer.select(['fruit', 'quantity'])
withoutDayOfSale.data() // { fruit: ['apple', 'apple', 'banana', 'banana'], quantity: [1, 2, 3, 4] }
```

<a name="datacontainer_rename" href="#datacontainer_rename">#</a> <i>DataContainer</i>.<b>rename</b>(renameInstructions)

`rename` is used to rename columns. `renameInstructions` must be an object with current column names as keys, and desired new column names as values.

```js
const dataContainer = new DataContainer({ f: ['apple', 'banana'], a: [1, 2] })
const renamed = dataContainer.rename({ f: 'fruit', a: 'amount' })
renamed.column('fruit') // ['apple', 'banana']
```

<a name="datacontainer_filter" href="#datacontainer_filter">#</a> <i>DataContainer</i>.<b>filter</b>(filterFunction)

`filter` will throw away all rows that do not satisfy the condition expressed in the `filterFunction`.

```js
const dataContainer = new DataContainer({ fruit: ['apple', 'banana'], amount: [1, 2] })
dataContainer.filter(row => row.fruit !== 'banana').data() // { fruit: ['apple'], amount: [1] }
```

<a name="datacontainer_dropna" href="#datacontainer_dropna">#</a> <i>DataContainer</i>.<b>dropNA</b>(dropNAInstructions)

`dropNA` is essentially a special case of `filter` that disposes of invalid values like `NaN`, `null` or `undefined`.
`dropNAInstructions` can be 

- `null`, in which case it will dispose of all rows in all columns that contain invalid values
- a `String` value with a column name. All rows that have invalid values in this column will be removed
- an `Array` of column names (`String`s). All rows that have invalid values in any of these columns will be removed

```js
const dataContainer = new DataContainer(
  { a: [1, 2, undefined, 4], b: [5, null, 7, 8], c: [NaN, 10, 11, 12] }
)

dataContainer.dropNA(null).data() // { a: [4], b: [8], c: [12] }
dataContainer.dropNA(['a', 'b']).data() // { a: [1, 4], b: [5, 8], c: [NaN, 12] }
```

<a name="datacontainer_arrange" href="#datacontainer_arrange">#</a> <i>DataContainer</i>.<b>arrange</b>(arrangeInstructions)

`arrange` is used to sort data. 

### Adding and removing rows